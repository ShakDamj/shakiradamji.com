---
published: 2014-03-18
title:
  en: Type.new() (üá™üá∏ only)
  es: Type.new()
---

> NOTA: Este art√≠culo est√° centrado en un tema que ya coment√© en [el post anterior][1], pero de una forma m√°s organizada y centrada, algunos fragmentos est√°n extra√≠dos del post anterior para mayor claridad.

## Constructores en Javascript

He hablado antes de la limitaci√≥n de los constructores javascript y sobre todo de la complejidad de extenderlos

<!-- end extract -->

```js
function Person(name) {
  this.name = name;
}
Person.prototype.methodA = function() { ... };

function Employee(name, position) {
  Person.call(this, name);
  this.position = position;
}
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.methodB = function() { ... };
```

Esto es un asunto que trae de cabeza a la mayor√≠a de la gente que programa javascript, la dificiltad que conlleva crear una simple "clase" hasta el punto que en la siguiente versi√≥n del ECMAScript (el est√°ndar en el que est√° basado Javascript) han inclu√≠do una forma m√°s sencilla de hacer lo mismo: la palabra clave `class`

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  methodA() {}
}

class Employee extends Person {
  constructor(name, position) {
    super(name);
    this.position = position;
  }
  methodB() {}
}
```

<a target="_blank" href="http://www.es6fiddle.net/hsq7hzw6/">Pru√©bame</a>

Aunque he visto a mucha gente emocionada pensando que ECMAScript 6 traer√° clases reales tengo que decir que este c√≥digo no hace ni m√°s ni menos que lo que hace el primer c√≥digo. Y es muy importante saberlo porque aunque prezcan classes como las de Java o C++, en este caso siguen siendo objetos usando [herencia por prototipos][2] y esconderlo solo servir√° para no saber porqu√© el c√≥digo no funciona como esperamos.

En cualquier caso vemos que definir tipos en javascript es complicado y la soluci√≥n propuesta por el equipo de ECMA no es, en mi opini√≥n, la m√°s adecuada.

## ¬†Orientado a objetos

Creo que el problema se aloja en la definici√≥n que dimos en un principio a "Programaci√≥n Orientada a Objetos" (Object Oriented Programming, OOP) ya que los primeros lenguajes OOP creaban objetos usando clases y otras herramientas, y aunque los objetos son la base del sistema la estructura est√° dada por las clases. Lo que ser√≠a Programaci√≥n Orientada a Objetos con Clases.

<!--more Seguir leyendo ‚Üí -->

Despu√©s recibimos otros lenguajes que tambi√©n se definian como "Programaci√≥n Orientados a Objetos" pero enfocado de otra forma, entre ellos javascript. En este caso el lenguaje no tiene clases sino que todo son objetos y la estructura se crea mediante prototipos, todo objeto puede ser el prototipo de otro objeto y esto significa que si B prototipa a A todas las propiedades que A tenga tambi√©n existir√°n en B. Esto es lo que llamo Programaci√≥n Orientada a Objetos con Prototipos.

Me he cruzado con mucha gente que piensa que la Programaci√≥n Orientada a Objetos no es posible sin clases y que si Javascript no tiene clases no puede denominarse orientado a objetos. Como en todo debate entre geeks acabamos en la wikipedia:

> La programaci√≥n orientada a objetos o POO (OOP seg√∫n sus siglas en ingl√©s) es un paradigma de programaci√≥n que usa los objetos en sus interacciones, para dise√±ar aplicaciones y programas inform√°ticos. Est√° basado en varias t√©cnicas, incluyendo herencia, cohesi√≥n, abstracci√≥n, polimorfismo, acoplamiento y encapsulamiento.

En resumen, un lenguaje orientado a objetos es el que tiene objetos (brillante conclusi√≥n) y cumple una serie de t√©cnicas (herencia, cohesi√≥n, abstracci√≥n, polimorfismo...) que en el caso de Java se hace mediante clases y en el caso de Javascript se hace mediante prototipos.

## ¬†Los inicios de Javascript

Javascript en sus inicios se llam√≥ LiveScript, cuenta la leyenda que por aquella √©poca Java estaba teniendo mucho √©xito y por marketing se decidi√≥ llamar al nuevo lenguaje JavaScript. Tambi√©n cuenta que por el mismo motivo a √∫ltima hora se decidi√≥ modificar el lenguaje para parecerse m√°s a Java a√±adiendo, entre otras funcionalidades, el operador `new` para que pareciera tener clases.

Hay algo muy curioso en los constructores Javascript, que en el fondo son simples funciones, y es que todas las funciones javascript tienen la propiedad `prototype` que por defecto trae un objeto que solo tiene una propiedad, la propiedad `constructor` que es el propio constructor.

```js
function Testing() {}
console.log(Testing.prototype.constructor === Testing);

var proto = Testing.prototype;
console.log(proto.constructor.prototype === proto);
```

## ¬†Constructores vs objetos prototipo

Esto me hace pensar que quiz√°s la intenci√≥n original de los objetos en javascript no era tener constructores que contienen prototipos sino tener prototipos que contienen constructores. Es decir: en lugar de...

```js
function MyType() {
  this.id = 1;
}
MyType.prototype.methodA = function() {¬†... }
```

Hacer esto...

```js
var MyType = {
  constructor: function() {
    this.id = 1;
  },
  methodA: function() { ... },
};
```

Vaya! No parece una forma mucho m√°s sencilla de declarar tipos? \[Aqu√≠\]\[5\] podemos comparar el mismo tipo escrito con constructores y con este paradigma y juzguen ustedes mismos. Y que pasa cuando intentamos invocar al constructor? hay que usar `.call()` o `.apply()` para pasarle this?

```js
var instancia = Object.create(MyType);
instancia.constructor();
```

BOOM! Constructor ya recibe this porque es invocado directamente en la instancia! No es exageradamente sencillo y l√≥gico desde √©ste punto de vista?

Adem√°s por accidente hemos quitado de en medio la funci√≥n constructora y lo que tenemos es un simple objeto, el elemento m√°s b√°sico de la programaci√≥n orientada a objetos. Es decir, para declarar un tipo solo tenemos que crear un objeto, para prototipar un objeto solo necesitamos un paso

```js
var SubType = Object.create(MyType);
```

No estamos obligados, a diferenia del primer caso, a crear un nuevo constructor para crear un subtipo, por la herencia por prototipos tenemos el mismo constructor que `MyType`

```js
console.log(SubType.constructor === MyType.constructor);
// true
```

<a target="_blank" href="http://jsfiddle.net/amatiasq/VRKYv/">Pru√©bame</a>

Y la mejor parte, que pasa si queremos crear un tipo sin constructor? No hay problema.

```js
var MyType = {};
console.log(MyType.constructor); // Object
```

<a target="_blank" href="http://jsfiddle.net/amatiasq/yGJLL/">Pru√©bame</a>

## ECMAScript 6

Este paradigma se parece bastante a la forma de crear clases en ECMAScript 6

```js
class MyType {
  constructor() {
    this.id = 1;
  }
  methodA() { ... }
}
```

Que alguno dir√°, si, pero con las clases de ECMAScript 6 podemos extender clases, llamar al m√©todo padre con `super` y nos ahorramos poner `function`... Pero esas no son funcionalidades de las clases de ECMAScript 6, esas son funcionalidades [de todos los objetos][3] en ECMAScript 6.

```js
// Clase ECMAScript 6
class Employee extends Person {
  constructor(name, postition) {
    super(name);
    this.position = postition;
  }
  methodA() { ... }
}

// Objeto en ECMAScript 6 est√°ndar
var Employee = {
  __proto__: Person,

  constructor() {
    super(name)
    this.id = 1;
  },
  methodA() { ... }
};
```

Las diferencias entre una clase ECMAScript 6 y un objeto en ECMAScript 6 son m√≠nimas, pero mientras que una clase nos hace pensar que `Employee` se comportar√° como una clase Java cuando no es as√≠, un objeto es simplemente eso, un objeto y todos somos capaces de entender como se comporta un objeto, no? (si no que haces leyendo esto? o.o)

Pero dejemos ECMAScript 6 de lado por ahora, que a√∫n tiene que transcurrir tiempo antes de que podamos usarlo en serio.

## Instanciaci√≥n

Hasta aqu√≠ era la definicion del tipo, pero como creamos una instancia? Primero tendr√≠amos que plantearnos que es una instancia, si no tenemos clases podemos tener instancias? Seg√∫n la wikipedia

> En el paradigma de la orientaci√≥n a objetos, una instancia (en ingl√©s, instance) se refiere a una realizaci√≥n espec√≠fica de una clase o prototipo determinados.

Pero, al menos a mi, no importa mucho la palabra; el tema es que nosotros creamos objetos para que hagan de prototipos y queremos crear "instancias" de estos prototipos. La forma de prototipar un objeto es usando `Object.create()`

```js
var instance = Object.create(MyType);
```

Pero, un momento... Esto es exactamente lo mismo que hicimos para crear un subtipo, no? Si. Entonces en que se diferencia una instancia de un subtipo? En general, nada. **Una instancia ES un subtipo**. Pero en la mayor√≠a de los casos las "instancias" tienen una necesidad que los subtipos no tienen: en una instancia se invoca al constructor, en un subtipo no.

```js
var MyType = {
  constructor: function () {
    this.id = 1;
  },
};

// Crear sub-tipo
var SubType = Object.create(MyType);

// Crear instancia
var instance = Object.create(MyType);
instance.constructor();
```

Esta similitud entre una instancia y un SubTipo nos ayuda a entender hasta que punto en el fondo Javascript es muy, muy sencillo: todo son objetos; no hay diferencia entre un tipo y una instancia porque la diferencia es conceptual.

Esto es muy √∫til para entender la sencillez y el coraz√≥n de Javascript, pero es un poco tedioso tener que hacer dos pasos para instanciar, podr√≠amos simplificarlo?

## `Type.new()` es el nuevo `new`

Lo cierto es que podr√≠amos, podemos hacer una funci√≥n que haga este proceso:

```js
function createInstance(Type) {
  var instance = Object.create(Type);
  instance.constructor();
  return instance;
}

var Type = {
  constructor: function () {
    this.id = 1;
  },
};

var instance1 = createInstance(Type);

var TypeWithoutConstructor = {};
var instance2 = createInstance(TypeWithoutConstructor);
```

<a target="_blank" href="http://jsfiddle.net/amatiasq/Jry2Z/">Pru√©bame</a>

Y que pasa si en lugar de llamarla `createInstance` la llamamos `$new` por ejemplo?

```js
var instance = $new(MyType);
```

Empieza a parecer similar, solo nos faltar√≠a cambiar la funcion `$new` para pasarle par√°metros al constructor

```js
function $new(Type, params) {
  var instance = Object.create(Type);
  instance.constructor.apply(instance, params);
  return instance;
}

var Type = {
  constructor: function (name) {
    this.name = name;
  },
};

var instance = $new(Type, ['bob']);
```

<a target="_blank" href="http://jsfiddle.net/amatiasq/t8QCk/">Pru√©bame</a>

Parece funcionar, pero solo para acabar de pulirlo, porqu√© no ponemos $new como m√©todo de Type? as√≠ podr√≠amos pasarle los argumentos sin el array y como ECMAScript 5 nos permite usar palabras clave como propiedades de objeto podemos llamarlo simplemente `new`.

```js
var Type = {
  new: function () {
    var instance = Object.create(this);
    instance.constructor.apply(instance, arguments);
    return instance;
  },
  constructor: function (name) {
    this.name = name;
  },
};

var instance = Type.new('bob');
```

<a target="_blank" href="http://jsfiddle.net/amatiasq/x3qM4/">Pru√©bame</a>

Y tenemos una forma que podemos usar con ECMAScript 5 para crear tipos e instancias de forma sencilla. Pero que diferencia hay entre esto y hacer un `new`? A parte de la ya mencionada simplicidad para crear y extender tipos, tiene m√°s ventajas, principalmente porque nos permite controlar m√°s exactamente **c√≥mo** se crea un objeto que en algunos casos es conveniente cambiarlo (en la mayor√≠a no), pero excede el alcance de √©ste post.

## ¬†Conclusi√≥n

Despu√©s de pasarme los √∫ltimos a√±os probando [mil][4] [y][5] [una][6] [formas][7] [de][8] [crear][9] [y][10] [extender][11] ["clases"][12] [para][13] [encontrar][14] [la][15] forma m√°s sencilla, r√°pida y elegante, muchas de ellas registradas en este blog; me quedo con [√©sta][16]. La lecci√≥n que me dio javascript es que no es conveniente luchar contra su naturaleza, si queremos usar javascript y no morir en el intento lo m√°s razonable es usar javascript y no tratarlo en contra de su naturaleza.

A√∫n est√° por verse pero creo que este sistema incluso puede competir cara a cara con las "clases" de ECMAScript 6, pero en cualquier caso la conversi√≥n entre un tipo creado por constructor y uno creado con este sistema es muy sencilla

Por ejemplo, convertir un tipo creado con este sistema a constructor para usarlo con `new`:

```js
var MyType = {
  myMethod: function() { ... },
};

function MyConstructor() {
  MyType.constructor.apply(this, arguments);
}
MyConstructor.prototype = MyType;
```

<a target="_blank" href="http://jsfiddle.net/amatiasq/tGD7G/">Pru√©bame</a>

O convertir un constructor a este paradigma:

```js
function MyConstructor() {
  this.value = 1;
}
MyConstructor.prototype.myMethod = function() { ... };

var MyType = MyConstructor.prototype;
// y si queres a√±adir new...
MyType.new = $new;
```

<a target="_blank" href="http://jsfiddle.net/amatiasq/5R4z2/">Pru√©bame</a>

## Inicializador

Para finalizar un bonus, despu√©s de toda esta traves√≠a me he dado cuenta que el constructor, que para javascript parece tan importante, no lo es tanto. Si nos paramos a mirar el constructor vemos que es una simple funci√≥n

```js
function MyType() { ... }
```

No tiene nada de especial, incluso podemos invocarla como una funci√≥n y no construye nada. Entonces qui√©n construye? `new`. Es el operador `new` el que crea el nuevo objeto y luego invoca el m√©todo llamado "constructor", que no se diferencia en nada de cualquier otro m√©todo que podr√≠a tener el objeto.

Por como yo lo veo, la funci√≥n del constructor es m√°s inicializar que construir, debe encargarse de inicializar las propiedades del objeto, no construir. Visto as√≠ es evidente que el nombre "constructor" no es apropiado, en mi caso prefiero la denominaci√≥n "initializer" o simplemente "init", como Backbone ya hace en sus objetos.

Por eso en mis proyectos cuando utilizo este paradigma, prefiero que mi funci√≥n `$new` invoque el m√©todo `init` en lugar de llamar al m√©todo `constructor`.

```js
function $new() {
  var obj = Object.create(this);
  obj.init.apply(obj, arguments);
  return obj;
}

var MyType = {
  new: $new,
  init: function () {
    this.value = 1;
  },
};

var instance = MyType.new();
```

<a target="_blank" href="http://jsfiddle.net/amatiasq/7h7Te/">Pru√©bame</a>

[1]: http://blog.amatiasq.com/2014/03/construccion-de-objetos/
[2]: http://blog.amatiasq.com/2012/01/javascript-conceptos-basicos-herencia-por-prototipos/
[3]: https://github.com/lukehoban/es6features#enhanced-object-literals
[4]: https://gist.github.com/amatiasq/4038135
[5]: https://gist.github.com/amatiasq/5215294
[6]: https://gist.github.com/amatiasq/5254098
[7]: https://gist.github.com/amatiasq/5619166
[8]: https://gist.github.com/amatiasq/6270563
[9]: https://github.com/amatiasq/LifeJS/blob/master/lib/animal.js
[10]: https://github.com/amatiasq/-legacy-BRIAP/blob/master/src/core/base.js
[11]: https://github.com/amatiasq/-legacy-bio/blob/master/src/core/Base.js
[12]: https://github.com/amatiasq/jsbase/blob/master/src/extend.js
[13]: https://github.com/amatiasq/-legacy-Life/blob/master/lib/physic/Force.dart
[14]: https://github.com/amatiasq/glib/blob/master/core/base.js
[15]: https://github.com/amatiasq/lulas/blob/master/src/core/extend.js
[16]: https://gist.github.com/amatiasq/7892749
